import asyncio
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union
from uuid import UUID
import httpx
from pydantic import BaseModel, Field
from sqlmodel import (
    SQLModel,
)  # SQLModel is used for schema definition here too for consistency

from app.core.config import settings  # For AIRTABLE_API_KEY, AIRTABLE_BASE_ID
from app.repositories.base import IRepository

ModelType = TypeVar(
    "ModelType", bound=SQLModel
)  # Using SQLModel as base for Pydantic models
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)


# Airtable specific Pydantic model for wrapping records
class AirtableRecord(BaseModel):
    id: str  # Airtable record ID
    createdTime: str
    fields: Dict[str, Any]


class AirtableListResponse(BaseModel):
    records: List[AirtableRecord]
    offset: Optional[str] = None


class AirtableRepository(
    IRepository[ModelType, CreateSchemaType, UpdateSchemaType],
    Generic[ModelType, CreateSchemaType, UpdateSchemaType],
):
    def __init__(self, model: Type[ModelType], table_name: str):
        self.model = model
        self.table_name = table_name
        self.base_url = (
            f"https://api.airtable.com/v0/{settings.AIRTABLE_BASE_ID}/{self.table_name}"
        )
        self.headers = {
            "Authorization": f"Bearer {settings.AIRTABLE_API_KEY}",
            "Content-Type": "application/json",
        }

    async def _request(self, method: str, url: str, **kwargs) -> httpx.Response:
        async with httpx.AsyncClient() as client:
            try:
                response = await client.request(
                    method, url, headers=self.headers, **kwargs
                )
                response.raise_for_status()  # Raise an exception for HTTP errors (4xx or 5xx)
                return response
            except httpx.HTTPStatusError as e:
                # Log error or handle specific statuses
                print(
                    f"Airtable API request failed: {e.response.status_code} - {e.response.text}"
                )
                # Consider re-raising a custom exception or returning a specific error model
                raise
            except httpx.RequestError as e:
                print(f"Airtable API request error: {e}")
                raise

    def _map_airtable_to_model(self, record: AirtableRecord) -> ModelType:
        # Airtable returns `id` and `createdTime` at the top level, `fields` contains the actual data.
        # We need to map `fields` to our ModelType and potentially include `id` as `airtable_record_id`
        # or map it to the model's `id` if it's a string and not UUID, or handle conversion.
        # For now, we assume our ModelType can be constructed from fields, and we add airtable_id.
        # This mapping needs to be robust based on how SQLModels are defined vs Airtable fields.

        # SQLModel expects UUID for id. Airtable gives a string. We need a strategy.
        # For now, let's assume the model has an `airtable_record_id: Optional[str]` field.
        # And that other fields match.
        model_data = record.fields.copy()
        model_data["airtable_record_id"] = record.id  # Store Airtable's own record ID

        # SQLModel's `id` is typically a UUID. If our model's `id` is meant to be the Airtable ID,
        # then the type hint for `id` in the model should be `str` or we need conversion.
        # For this generic adapter, we'll assume `id` in the model is separate from Airtable's record ID.
        # If a model has an `id` field that's a UUID, it won't be set from Airtable directly here unless mapped.

        # A simple approach: if the model has `id` and it's not in fields, try to use airtable record id if it's a UUID (unlikely)
        # Or, more likely, the model's primary `id` (UUID) is generated by our app, and Airtable ID is just a reference.
        return self.model(**model_data)

    def _map_model_to_airtable_fields(
        self, obj_in: Union[CreateSchemaType, UpdateSchemaType, Dict[str, Any]]
    ) -> Dict[str, Any]:
        if isinstance(obj_in, dict):
            data = obj_in
        else:
            data = obj_in.model_dump(exclude_unset=True, exclude_none=True)

        # Remove fields that Airtable doesn't manage or that are specific to our DB models (like local UUID `id`)
        # This needs careful consideration based on model structure.
        data.pop("id", None)  # Don't send our internal UUID `id` to Airtable as a field
        data.pop("created_at", None)
        data.pop("updated_at", None)
        data.pop(
            "airtable_record_id", None
        )  # This is Airtable's ID, not a field to set
        return {"fields": data}

    async def create(self, *, obj_in: CreateSchemaType, **kwargs) -> ModelType:
        payload = self._map_model_to_airtable_fields(obj_in)
        response = await self._request("POST", self.base_url, json=payload)
        created_record = AirtableRecord(**response.json())
        return self._map_airtable_to_model(created_record)

    async def get(
        self, *, id: str, **kwargs
    ) -> Optional[ModelType]:  # Airtable ID is a string
        # `id` here is Airtable's record ID
        url = f"{self.base_url}/{id}"
        try:
            response = await self._request("GET", url)
            record = AirtableRecord(**response.json())
            return self._map_airtable_to_model(record)
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                return None
            raise

    async def get_multi(
        self,
        *,
        skip: int = 0,  # Airtable uses offset, not skip. Limit is `pageSize`.
        limit: int = 100,
        filters: Optional[Dict[str, Any]] = None,  # Airtable uses `filterByFormula`
        **kwargs,
    ) -> List[ModelType]:
        params = {"pageSize": limit}
        # Airtable's `offset` is a string token from previous response, not an integer skip.
        # True pagination with skip/limit is complex with Airtable if not using their offset.
        # For simplicity, we'll fetch `limit` records. If `skip` is used, it's harder.
        # A more robust solution would handle Airtable's pagination via `offset`.

        if filters:
            # Construct filterByFormula. Example: AND({Name} = 'John', {Age} > 30)
            # This is highly dependent on the filter structure provided.
            # For a generic solution, this part needs to be very flexible or simplified.
            # Example: filters = {"Name": "John", "Status": "Active"} -> "AND({Name}='John', {Status}='Active')"
            formula_parts = []
            for key, value in filters.items():
                if isinstance(value, str):
                    formula_parts.append(f"{{{key}}}='{value}'")
                else:
                    formula_parts.append(f"{{{key}}}={value}")
            if formula_parts:
                params["filterByFormula"] = "AND(" + ", ".join(formula_parts) + ")"

        all_records: List[ModelType] = []
        current_offset: Optional[str] = kwargs.get(
            "offset"
        )  # Allow passing initial offset

        # Simplified: fetch up to `limit` records, ignoring `skip` for now due to Airtable's offset mechanism
        # A proper implementation would loop with `offset` until enough records are fetched to satisfy `skip` and `limit`.
        if current_offset:
            params["offset"] = current_offset

        response = await self._request("GET", self.base_url, params=params)
        response_data = AirtableListResponse(**response.json())

        for record_data in response_data.records:
            all_records.append(self._map_airtable_to_model(record_data))

        # This is a simplified get_multi. A full version would handle pagination to fetch more if needed.
        return all_records

    async def update(
        self,
        *,
        db_obj_id: str,  # Airtable record ID
        obj_in: Union[UpdateSchemaType, Dict[str, Any]],
        **kwargs,
    ) -> ModelType:
        url = f"{self.base_url}/{db_obj_id}"
        payload = self._map_model_to_airtable_fields(obj_in)
        # Airtable PATCH request should not include read-only fields in the main payload
        # The `fields` dict should only contain what's being updated.
        response = await self._request("PATCH", url, json=payload)
        updated_record = AirtableRecord(**response.json())
        return self._map_airtable_to_model(updated_record)

    async def delete(
        self, *, id: str, **kwargs
    ) -> Optional[ModelType]:  # Airtable ID is string
        url = f"{self.base_url}/{id}"
        try:
            # First, get the object to return it, as Airtable delete returns {deleted: true, id: ...}
            obj_to_delete = await self.get(id=id)
            if not obj_to_delete:
                return None  # Already deleted or never existed

            await self._request("DELETE", url)
            return obj_to_delete  # Return the object that was deleted
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                return None
            raise

    async def get_by_attribute(
        self, *, attribute_name: str, attribute_value: Any, **kwargs
    ) -> Optional[ModelType]:
        # Use filterByFormula for this
        formula = (
            f"{{{attribute_name}}}='{attribute_value}'"
            if isinstance(attribute_value, str)
            else f"{{{attribute_name}}}={attribute_value}"
        )
        params = {"filterByFormula": formula, "maxRecords": 1}
        response = await self._request("GET", self.base_url, params=params)
        response_data = AirtableListResponse(**response.json())
        if response_data.records:
            return self._map_airtable_to_model(response_data.records[0])
        return None

    async def get_multi_by_attribute(
        self,
        *,
        attribute_name: str,
        attribute_value: Any,
        skip: int = 0,  # Again, skip is tricky with Airtable
        limit: int = 100,
        **kwargs,
    ) -> List[ModelType]:
        formula = (
            f"{{{attribute_name}}}='{attribute_value}'"
            if isinstance(attribute_value, str)
            else f"{{{attribute_name}}}={attribute_value}"
        )
        params = {"filterByFormula": formula, "pageSize": limit}
        # Handle skip/offset if needed, similar to get_multi
        response = await self._request("GET", self.base_url, params=params)
        response_data = AirtableListResponse(**response.json())
        return [self._map_airtable_to_model(r) for r in response_data.records]


# Note: This Airtable adapter is a basic implementation.
# Error handling, pagination, and field mapping would need to be more robust for production use.
# Also, ensure AIRTABLE_BASE_ID and AIRTABLE_API_KEY are in settings.
